<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>React - knowledge summary</title>

    <style>
        html {
            scroll-behavior: smooth;
        }

        body {
            max-width: 80%;
            margin: auto;
            background-color: #434343;
            color: #efefef;
            font-size: 20px;
            font-family: roboto, arial, sans-serif;
        }

        pre {
            min-width: 1000px;
            padding-top: 20px;
            border-radius: 10px;
            background-color: #f5f5f5;
            color: black;
            font-size: 0.9em;
        }

        span {
            color: royalblue;
            font-size: 1.2em;
            font-weight: bold;
        }

        .lineThrough {
            text-decoration: line-through;
            color: goldenrod;
            font-size: 1em;
        }

        h4 {
            color: chocolate;
            font-style: italic;
        }

        a {
            text-decoration: none;
            color: white;
            transition: 0.3s;
        }

        a:hover {
            color: royalblue;
        }
    </style>
</head>

<body>
    <h2>React knowledge summary:</h2>

    <h3>Spis treści:</h3>
    <ul>
        <li><a href="#jxs">JXS</a></li>
        <li><a href="#komponenty">Komponenty</a></li>
        <li><a href="#state">State</a></li>
        <li><a href="#props">Props</a></li>
        <li><a href="#this">Problem z 'this'</a></li>
        <li><a href="#destructurung">Destruktyryzacja</a></li>
        <li><a href="#form">Formularze</a></li>
        <li><a href="#reactRouter">React Router</a></li>
        <li><a href=""></a></li>
        <li><a href=""></a></li>
        <li><a href=""></a></li>
    </ul>


    <section>
        <h3 id="jxs">JXS:</h3>
        <pre>
            <span>JXS</span> - preprocesor, Babel zamienia go na czysty JavaScript
            - atrybuty muszą być pisane camelCase
            - by uniknąć automatycznego średnika po return, należy użyć nawiasów:
                <span>return (
                code...
                );</span>
            - musi być jeden element nadrzędny w return, nawet same nawiasy &lt> &lt/>
              lub możemy też użyć &ltReact.Fragment> &lt/React.Fragment>
            - JSX po kompilacji wywołuje metodę React.createElement
                <span>React.createElement( type, props, children)</span>
                np:
                &ltp id="someId" class="someClass"> Hello world! &lt/p>
                kompiluje tak:
                React.createElement (
                    "p",
                    { id: "someId" class: "someClass" },
                    "Hello world!"
                );
            - za pomocą nawiasów klamrowych można przekazać wyrażenie czystego JS
                <span>&ltp> Mnożenie { number * 2 } &lt/p></span>
            - tworzenie komentarzy:  {/*  */}
            - trzeba domykać znaczniki np. <span>&ltimg src="" /></span>
            - zamiast class jest className
            - zamiast for jest htmlFor
            </pre>
    </section>

    <section>
        <h3 id="komponenty">Komponenty:</h3>
        <pre>
            Instancja komponentu:
            <span>
            &ltNazwaKomponentu/>
            </span>
            lub
            <span>
            &ltNazwaKomponentu>
                Jakiś props.children
            &ltNazwaKomponentu/>
            </span>
            Komponent bezstanowy - funkcyjny:
            <span>
            const App = (props) => {
                return (
                    &ltdiv&gt
                        &lth1&gt Komponent  funkcyjny &lt/h1&gt
                    &lt/div&gt
                )
            }
            ReactDOM.render( &ltApp/>, document.getElementById('root'));
            </span>
            Komponent stanowy -  klasowy:
            <span>
            class App2 extends React.Component {
                state = {
                    name: 0,
                }
                render() {
                    return (
                        &ltdiv>
                            &lth1> Komponent klasowy {this.state.name} &lt/h1>
                        &lt/div>
                    )
                } 
            }
            ReactDOM.render( &ltApp2/>, document.getElementById('root'));
            </span>
            - komponent klasowy wymaga dziedziczenia z klasy Component, która jest w React
            - musi być w nim metoda render a w niej return
            - duże litery w nazwie

            Komponent nadrzędny:
            <span>
            const Application = () => {
                return (
                    &lt>
                        &ltApp/>
                        &ltApp2/>
                    &lt/>
                    
                )
            }
            </span>
        </pre>
    </section>

    <section>
        <h3 id="state">State:</h3>
        <pre>
            State (stan) - obiekt należący do komponentu stanowego (klasowego).
                           Ich zmiana pociąga za sobą aktualizację komponentu

            - state możemy zadeklarować bezpośrednio w klasie: 
            <span>
            class App extends React.Component {
                state {
                    ...
                }
            }
            </span>
            - state możemy też zadeklarować w konstruktorze:
            <span>
            class App extends React.Component {
                constructor(props){
                    super(props);
                    this.state = {...}
                }
            }
            </span>
            Zmiany w stanie mogą być dokonywane za pomocą metody <span>setState</span>
            
            1. Zwracamy obiekt:
            <span>
            handleClick(letter){
                this.setState({
                    text: this.state.text + letter
                })
            }
            </span>
            2. Funkcja zwracająca obiekt:
            <span>
            handleClick(letter){
                this.setState( prevState => ({
                    text: prevState + letter
                }))
            }
            </span>
            </pre>
    </section>

    <section>
        <h3 id="props">Props:</h3>
        <pre>
            Props (właściwość) - obiekt przechowujący dane przekazane do komponentu.
                                 Przepływ danych od rodzica do dziecka.
                                 Są to właściwości tylko do odczutu.
            <span>
            &ltListItem
                title = "Hello"
                options = {...}
                visible
            />
            </span>
            a wygląda to tak:
            <span>
            props: {
                title: 'hello',
                options: {...},
                visible: true
            }
            </span>
            Jeżeli do nazwy właściwości nie przekażemy wartości jak w "visible",
            to przypisane zostanie <span>true</span>.

            Props znajduje się w każdym komponencie:
            a) w komponencie klasowym używamy: this.props.nazwa
            <span>
            class App extends React.Component {
                render() {
                    console.log(this.props.name);
                    return (...)
                }
            }
            </span>
            b) w komponencie funkcyjnym używamy: props.nazwa
            <span>
            const App = (props) => {
                console.log(props);
                return (
                    &ltdiv> {props.name} &lt/div>
                )
            }
            </span>
            Domyślne wartości możemy zapisać w wartości statycznej w komponencie, 
            używając nazwy "defaultProps":
            <span>
            static defaultProps = {
                name: "...",
            }
            </span>
            lub poza komponentem jako:
            <span>
                NazwaKomponentu.defaultProps{
                    name: "...",
                }
            </span>
            </pre>
    </section>

    <section>
        <h3 id="this">Rozwiązanie problemu z this:</h3>
        <pre>
            1. Bind
            <span>
            handleClick(){
                console.log(this)
            }
            return (
                &ltinput onChange = {this.handleClick.bind(this)} />
            )
            </span>
            2. Wiązanie w konstruktorze
            <span>
            constructor(props){
                super(props);
                this.handleClick = this.handleClick.bind(this)
            }
            handleClick(){
                console.log(this)
            }
            return (
                &ltinput onChange = {this.handleClick} />
            )
            </span>
            3. Funkcja strzałkowa
            <span>
            handleClick = () => {
                console.log(this)
            }
            return (
                &ltinput onChange = {this.handleClick} />
            )
            </span>
            4. Anonimowa funkcja strzałkowa
            <span>
            handleClick() {
                console.log(this)
            }
            return (
                &ltinput onChange = {() => this.handleClick()} />
            )
            </span>
            5. Deklaracja metody i jej przypisanie
            <span>
            handleClick() {
                console.log(this)
            }
            handleClick = this.handleClick.bind(this)
            return (
                &ltinput onChange = {this.handleClick} />
            )
            </span>
            </pre>
    </section>

    <section>
        <h3 id="destructurung">Destruktyryzacja:</h3>
        <pre>
            <span>Destruktyryzacja</span> - pozwala wyodrębnić informację z tablic i obiektów.
             
            <span>Obiekt:</span>
            const player = {
                age: 25,
                name: "Jack"
            };

            // ES5:
            const age = player.age, name = player.name;

            // ES6:
            const {age, name} = player;

            // Zmiana nazwy:
            const { age: playerAge, name: playerName} = player;

            <span>Tablica:</span>
            const players = ['Jack', 'Emma'];

            const [user_1, user_2] = players;

            // Sposób na kopie tablicy:
            const [...newPlayers] = players;

            <span>Wykorzystanie w React:</span>
            const {id, value, item} = this.state;
        </pre>
    </section>

    <section>
        <h3 id="form">Formularze:</h3>
        <pre>
            <span>Controlled Component - Komponent kontrolowany</span>
            1. Wykorzystanie state do trzymania aktualnej wartości elementów formularza
            2. Wykorzystanie atrybutów value i checked
            3. Zmiana właściwości state za pomocą metody onChange (na polu), onSubmit (na formularzu)

            // Przykład:

            state = {
                text: ""
            }

            handleChange = (e) => {
                this.setState({
                    text: e.taget.value         // (*)
                })
            };

            &lt;input
                type="text"
                value={this.state.text}         // (*)
                onChange={this.handleChange}
            />

            * Dla type='checkbox' oraz type='radio', będzie <span>checked</span> oraz <span>e.target.checked</span>
              Dla pozostałych będzie <span>value</span> oraz <span>e.target.value</span>

            
            <span>Uncontrolled Component - Komponent niekontrolowany</span>
            1. Wykorzystanie atrybutu reference
            2. Odwołuje się za pomocą this.refs
            3. Domyślna wartość za pomocą defaultValue / defaultChecked

            // Przykład:

            handleSubmit = (e) => {
                e.preventDefault();
               const name = this.refs.username.value;
                // dodanie do jakieś tablicy lub state
                this.refs.username.value = '';
            }
        
            render() {
                return (
                    &lt;form onSubmit={this.handleSubmit}>
                        &lt;input
                            type="text"
                            ref="username"
                            defaultValue="Name"
                        />
                        &lt;button type="submit">Potwierdź&lt;/button>
                    &lt;/form>
                )
            }

            4. Alernatywnie możemy dostać się do właściwości przez e.target.elements

            handleSubmit = (e) => {
                e.preventDefault();
                const name = e.target.elements.username.value;
                // dodanie do jakieś tablicy lub state
                e.target.elements.username.value = '';
            }
        
            render() {
                return (
                    &lt;form onSubmit={this.handleSubmit}>
                        &lt;input
                            type="text"
                            name="username"
                        />
                        &lt;button type="submit">Potwierdź&lt;/button>
                    &lt;/form>
                )
            }
        </pre>
    </section>

    <section>
        <h3 id="reactRouter">React Router:</h3>
        <pre>
            <span>React Router</span> - biblioteka, dostarcza nam komponenty, które obsługują routing:
            1. modydikuje URL
            2. po wykonaniu modyfikacji ponownie renderuje aplikację
            3. rozponaje URL i określa jakie komponenty mają być (a jakie nie) wyświetlane dla danej lokalizacji.

            Instalacja:
            <span>npm install react-router-dom</span>
            Import:
            <span>import {BrowserRouter, Route, NavLink... } from 'react-router-dom'</span>

            1. <span>&lt;BrowserRouter></span> - komponent będący rodzicem, rdzeniem routingu w naszej aplikacji.
            Może posiadać tylko jedno dziecko.
            <span>
                &lt;BrowserRouter>
                    &lt;App>
                &lt;/BrowserRouter>
            </span>
            LUB
            <span>
            return (
                &lt;BrowserRouter>
                    &lt;div> ... &lt;/div>
                &lt;/BrowserRouter>
            )
            </span>
            2. &lt;Route> - komponenty dobierające, określają kiedy i co wyświetlić.
            Jeżeli ścieżka zgadza się z URL, renderowany jest komponent:
            <span>&lt;Route path="/contact" component={Contact} /></span>

            3. &lt;Switch> - kontener na wszystkie &lt;Route> - Zwraca pierwszy pasujący route!
                <span>
                    &lt;Switch>
                        &lt;Route>
                    &lt;/Switch>
                </span>

            4. &lt;Link>, &lt;NavLink> - komponenty nawigacyjne:
            <span>&lt;Link to="/contact">Kontakt&lt;/Link></span>
            <span>&lt;NavLink to="/contact">Kontakt&lt;/NavLink></span>
            NavLink:
            - do nawigacji linkami w nav
            - to="/"  -adres linku
            - dodaje klase "active" do aktywnego linka, który klikneliśmy.
            - możemy użyć "activeClassName" do przypisania jakieś nowej klasy
            - activeStyle{{}} - możemy dopisać liniowo style
        </pre>
    </section>

</body>

</html>